<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EulerSwap NAV Tracker</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 30px; }
        h1 { font-size: 2.5em; margin-bottom: 10px; }
        .subtitle { opacity: 0.9; }
        .card { background: white; border-radius: 12px; padding: 20px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .input-group { display: flex; gap: 10px; margin-bottom: 20px; }
        input { flex: 1; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 16px; }
        input:focus { outline: none; border-color: #667eea; }
        button { padding: 12px 24px; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: 600; }
        button:hover { background: #5a67d8; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .loading { text-align: center; padding: 40px; color: #666; }
        .error { background: #fee; color: #c00; padding: 12px; border-radius: 8px; margin-bottom: 20px; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .metric { text-align: center; }
        .metric-label { color: #666; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; }
        .metric-value { font-size: 24px; font-weight: bold; color: #333; }
        .metric-value.green { color: #10b981; }
        .metric-value.red { color: #ef4444; }
        .chart-container { position: relative; height: 400px; margin: 20px 0; }
        canvas { width: 100% !important; height: 100% !important; }
        .pool-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid #e0e0e0; }
        .token-pair { font-size: 24px; font-weight: bold; color: #333; }
        .pool-address { font-family: monospace; color: #666; font-size: 12px; }
        .fee-badge { background: #f0f0f0; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; }
        .data-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        .data-table th, .data-table td { padding: 12px; text-align: left; border-bottom: 1px solid #e0e0e0; }
        .data-table th { background: #f8f8f8; font-weight: 600; color: #666; font-size: 12px; text-transform: uppercase; }
        .data-table tr:hover { background: #f8f8f8; }
        .export-btn { background: #10b981; font-size: 14px; padding: 8px 16px; }
        .export-btn:hover { background: #059669; }
        .tab-nav { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0; }
        .tab { padding: 12px 20px; background: none; border: none; color: #666; cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -2px; }
        .tab.active { color: #667eea; border-bottom-color: #667eea; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .spinner { border: 3px solid #f3f3f3; border-top: 3px solid #667eea; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .terminal { background: #1e1e1e; color: #d4d4d4; padding: 20px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 12px; max-height: 400px; overflow-y: auto; white-space: pre-wrap; word-break: break-all; margin-top: 20px; }
        .terminal-line { margin: 4px 0; line-height: 1.4; }
        .terminal-comment { color: #6a9955; }
        .terminal-url { color: #ce9178; }
        .terminal-success { color: #4fc1ff; }
        .terminal-error { color: #f48771; }
        .terminal-json { color: #d7ba7d; }
        .terminal-timestamp { color: #858585; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåä EulerSwap NAV Tracker</h1>
            <p class="subtitle">Track Net Asset Value for any EulerSwap pool</p>
        </div>

        <div class="card" style="background: #fef3c7; border: 1px solid #f59e0b; display: none;" id="corsNotice">
            <p style="color: #92400e; margin: 0;">
                <strong>‚ö†Ô∏è Limited Mode:</strong> Running from file:// - Volume data unavailable due to browser security.
                <br>For full data, run: <code style="background: white; padding: 2px 4px; border-radius: 3px;">python3 -m http.server 8000</code> then visit 
                <a href="http://localhost:8000/eulerswap_nav_tracker.html" style="color: #92400e;">http://localhost:8000/</a>
            </p>
        </div>

        <div class="card">
            <div class="input-group">
                <input type="text" id="poolAddress" placeholder="Enter pool address (0x...)" value="0x794138c7067d38a46CE29fc84bA661678fAAe8a8">
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <label for="days" style="font-size: 11px; color: #666; margin-bottom: 2px;">Max Days</label>
                    <input type="number" id="days" placeholder="30" value="30" min="1" max="365" style="width: 80px;">
                </div>
                <button onclick="fetchPoolData()">Analyze Pool</button>
            </div>
            <div id="error" class="error" style="display: none;"></div>
        </div>

        <div id="results" style="display: none;">
            <div class="card">
                <div class="pool-info">
                    <div>
                        <div class="token-pair" id="tokenPair">-</div>
                        <div class="pool-address" id="poolAddr">-</div>
                    </div>
                    <div>
                        <span class="fee-badge" id="feeBadge">-</span>
                        <button class="export-btn" onclick="exportToCSV()">Export CSV</button>
                    </div>
                </div>

                <div class="metrics" id="metrics">
                    <div class="metric">
                        <div class="metric-label">Current NAV</div>
                        <div class="metric-value" id="currentNav">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">24h Change</div>
                        <div class="metric-value" id="navChange">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Total Fees</div>
                        <div class="metric-value" id="totalFees">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Total NAV APR</div>
                        <div class="metric-value" id="navApr">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Fee APR</div>
                        <div class="metric-value" id="feeApr">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Total Volume</div>
                        <div class="metric-value" id="totalVolume">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Total Swaps</div>
                        <div class="metric-value" id="totalSwaps">-</div>
                    </div>
                </div>
                
                <!-- Additional Statistics Row -->
                <div class="metrics" style="margin-top: 15px;">
                    <div class="metric">
                        <div class="metric-label">Avg Daily Volume</div>
                        <div class="metric-value" id="avgDailyVolume">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Max Daily NAV</div>
                        <div class="metric-value" id="maxNav">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Min Daily NAV</div>
                        <div class="metric-value" id="minNav">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">NAV Volatility</div>
                        <div class="metric-value" id="navVolatility">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Best Day</div>
                        <div class="metric-value" id="bestDay">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Worst Day</div>
                        <div class="metric-value" id="worstDay">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Sharpe Ratio</div>
                        <div class="metric-value" id="sharpeRatio">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Win Rate</div>
                        <div class="metric-value" id="winRate">-</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="tab-nav">
                    <button class="tab active" onclick="switchTab('chart')">NAV Chart</button>
                    <button class="tab" onclick="switchTab('returns')">Daily Returns</button>
                    <button class="tab" onclick="switchTab('volume')">Volume & Fees</button>
                    <button class="tab" onclick="switchTab('drawdown')">Drawdown</button>
                    <button class="tab" onclick="switchTab('table')">Daily Data</button>
                    <button class="tab" onclick="switchTab('composition')">Pool Composition</button>
                    <button class="tab" onclick="switchTab('terminal')">API Logs</button>
                </div>

                <div id="chart-tab" class="tab-content active">
                    <div class="chart-container">
                        <canvas id="navChart"></canvas>
                    </div>
                </div>

                <div id="table-tab" class="tab-content">
                    <table class="data-table" id="dataTable">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>NAV (USD)</th>
                                <th>Change</th>
                                <th>Volume</th>
                                <th>Fees</th>
                                <th>Swaps</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                </div>

                <div id="composition-tab" class="tab-content">
                    <div class="chart-container">
                        <canvas id="compositionChart"></canvas>
                    </div>
                </div>

                <div id="returns-tab" class="tab-content">
                    <div class="chart-container">
                        <canvas id="returnsChart"></canvas>
                    </div>
                </div>

                <div id="volume-tab" class="tab-content">
                    <div class="chart-container">
                        <canvas id="volumeChart"></canvas>
                    </div>
                </div>

                <div id="drawdown-tab" class="tab-content">
                    <div class="chart-container">
                        <canvas id="drawdownChart"></canvas>
                    </div>
                </div>

                <div id="terminal-tab" class="tab-content">
                    <div class="terminal" id="terminalOutput"></div>
                </div>
            </div>
        </div>

        <div id="loading" class="card loading" style="display: none;">
            <div class="spinner"></div>
            <p>Fetching pool data...</p>
            <p id="loadingStatus" style="font-size: 14px; color: #999; margin-top: 10px;"></p>
        </div>
    </div>

    <script>
        // Configuration
        const V2_API = 'https://index-dev.eul.dev/v2/swap/pools';
        const GRAPHQL_API = 'https://index-dev.euler.finance/graphql';
        const RPC_URL = 'https://ethereum.publicnode.com';
        
        let currentData = null;
        let navChart = null;
        
        // Check if running from file:// and show warning
        window.addEventListener('DOMContentLoaded', () => {
            if (window.location.protocol === 'file:') {
                document.getElementById('corsNotice').style.display = 'block';
            }
        });
        let compositionChart = null;
        let apiLogs = [];

        // Known token decimals to avoid RPC calls
        const KNOWN_DECIMALS = {
            '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 6, // USDC
            '0xdac17f958d2ee523a2206206994597c13d831ec7': 6, // USDT
            '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599': 8, // WBTC
        };

        function logToTerminal(message, type = 'info') {
            const timestamp = new Date().toISOString();
            const logEntry = { timestamp, message, type };
            apiLogs.push(logEntry);
            
            // Update terminal display if visible
            const terminal = document.getElementById('terminalOutput');
            if (terminal) {
                const line = document.createElement('div');
                line.className = 'terminal-line';
                
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'terminal-timestamp';
                timestampSpan.textContent = `[${timestamp.split('T')[1].split('.')[0]}] `;
                
                const messageSpan = document.createElement('span');
                messageSpan.className = `terminal-${type}`;
                messageSpan.textContent = message;
                
                line.appendChild(timestampSpan);
                line.appendChild(messageSpan);
                terminal.appendChild(line);
                
                // Auto-scroll to bottom
                terminal.scrollTop = terminal.scrollHeight;
            }
        }

        async function fetchPoolData() {
            const poolAddress = document.getElementById('poolAddress').value.trim();
            const days = parseInt(document.getElementById('days').value) || 30;
            
            if (!poolAddress || !poolAddress.startsWith('0x') || poolAddress.length !== 42) {
                showError('Please enter a valid pool address');
                return;
            }

            showLoading(true);
            hideError();
            currentData = null;
            apiLogs = [];
            document.getElementById('terminalOutput').innerHTML = '';

            try {
                updateStatus('Fetching pool metadata...');
                
                // Get current pool data
                const poolData = await fetchCurrentPoolData(poolAddress);
                if (!poolData) {
                    throw new Error('Pool not found. It may be inactive or not exist.');
                }

                updateStatus('Fetching historical prices...');
                
                // Get historical data
                const historicalData = await fetchHistoricalData(poolAddress, poolData, days);
                
                currentData = {
                    pool: poolData,
                    historical: historicalData
                };

                displayResults(currentData);
            } catch (error) {
                console.error('Error:', error);
                showError(error.message || 'Failed to fetch pool data');
            } finally {
                showLoading(false);
            }
        }

        async function fetchCurrentPoolData(poolAddress) {
            logToTerminal(`Fetching V2 API: ${V2_API}?chainId=1`, 'url');
            
            const response = await fetch(`${V2_API}?chainId=1`);
            const pools = await response.json();
            
            logToTerminal(`V2 API Response: ${pools.length} pools returned`, 'success');
            
            for (const pool of pools) {
                if (pool.pool.toLowerCase() === poolAddress.toLowerCase()) {
                    logToTerminal(`Found pool in V2 API!`, 'success');
                    logToTerminal(`Raw pool data:\n${JSON.stringify(pool, null, 2)}`, 'json');
                    return pool;
                }
            }
            
            logToTerminal(`Pool not found in V2 API, trying GraphQL...`, 'comment');
            
            // Try GraphQL for inactive pools
            const query = `
                query {
                    pools: eulerSwapFactoryPoolDeployeds(
                        where: {chainId: 1, pool: "${poolAddress.toLowerCase()}"}
                    ) {
                        items {
                            pool
                            asset0
                            asset1
                            createdAt
                        }
                    }
                }
            `;
            
            logToTerminal(`GraphQL Query: ${GRAPHQL_API}`, 'url');
            logToTerminal(`Query:\n${query}`, 'comment');
            
            const graphqlResponse = await fetch(GRAPHQL_API, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query })
            });
            
            const graphqlData = await graphqlResponse.json();
            logToTerminal(`GraphQL Response:\n${JSON.stringify(graphqlData, null, 2)}`, 'json');
            
            const items = graphqlData?.data?.pools?.items || [];
            
            if (items.length > 0) {
                logToTerminal(`Found pool in GraphQL!`, 'success');
                return items[0];
            }
            
            logToTerminal(`Pool not found in any API`, 'error');
            
            return null;
        }

        async function fetchHistoricalData(poolAddress, poolData, days) {
            const endDate = new Date();
            endDate.setHours(0, 0, 0, 0);
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - days);
            startDate.setHours(0, 0, 0, 0);
            
            // Get pool creation date to avoid querying before it existed
            const createdAt = poolData.createdAt ? new Date(parseInt(poolData.createdAt) * 1000) : null;
            if (createdAt && createdAt > startDate) {
                logToTerminal(`Pool created on ${createdAt.toISOString().split('T')[0]}, adjusting start date`, 'info');
                startDate.setTime(createdAt.getTime());
            }
            
            const historicalData = [];
            const token0 = poolData.vault0?.asset || poolData.asset0;
            const token1 = poolData.vault1?.asset || poolData.asset1;
            
            // Get token symbols and decimals
            const token0Symbol = await getTokenSymbol(token0);
            const token1Symbol = await getTokenSymbol(token1);
            const decimals0 = await getTokenDecimals(token0);
            const decimals1 = await getTokenDecimals(token1);
            
            logToTerminal(`Fetching historical data for ${days} days...`, 'info');
            
            // Get pool fee rate (in basis points / 10000)
            const feeRate = poolData.poolParams?.fee ? parseFloat(poolData.poolParams.fee) / 1e18 : 0.00005;
            logToTerminal(`Pool fee rate: ${(feeRate * 10000).toFixed(2)} bps`, 'info');
            
            // First, fetch all swap events for volume calculation
            const swapVolumes = await fetchSwapVolumes(poolAddress, startDate, endDate, decimals0, decimals1, token0, token1, feeRate);
            
            // Now fetch daily NAV data
            const currentDate = new Date(endDate);
            let previousNav = null;
            
            while (currentDate >= startDate) {
                const dateStr = currentDate.toISOString().split('T')[0];
                updateStatus(`Fetching data for ${dateStr}...`);
                
                // Estimate block number for this date (midnight UTC)
                const blockNumber = estimateBlockNumber(currentDate);
                
                try {
                    // Fetch pool data at this historical block
                    const historicalPoolData = await fetchPoolDataAtBlock(poolAddress, blockNumber);
                    
                    let nav = 0;
                    if (historicalPoolData && historicalPoolData.accountNav && historicalPoolData.accountNav.nav) {
                        // V2 API NAV in 8 decimals
                        nav = parseFloat(historicalPoolData.accountNav.nav) / 1e8;
                    }
                    
                    // Get volume data for this date
                    const dayVolume = swapVolumes[dateStr] || { volume: 0, swaps: 0, fees: 0 };
                    
                    historicalData.push({
                        date: dateStr,
                        nav: nav,
                        navChange: previousNav ? nav - previousNav : 0,
                        navChangePercent: previousNav ? ((nav - previousNav) / previousNav * 100) : 0,
                        volume: dayVolume.volume,
                        fees: dayVolume.fees,
                        swaps: dayVolume.swaps,
                        blockNumber: blockNumber,
                        token0Symbol,
                        token1Symbol,
                        decimals0,
                        decimals1
                    });
                    
                    previousNav = nav;
                    
                } catch (error) {
                    console.error(`Failed to fetch data for ${dateStr}:`, error);
                    logToTerminal(`Error fetching ${dateStr}: ${error.message}`, 'error');
                    
                    // Add placeholder data for failed fetch
                    historicalData.push({
                        date: dateStr,
                        nav: previousNav || 0,
                        navChange: 0,
                        navChangePercent: 0,
                        volume: swapVolumes[dateStr]?.volume || 0,
                        fees: swapVolumes[dateStr]?.fees || 0,
                        swaps: swapVolumes[dateStr]?.swaps || 0,
                        blockNumber: blockNumber,
                        token0Symbol,
                        token1Symbol,
                        error: true
                    });
                }
                
                // Move to previous day
                currentDate.setDate(currentDate.getDate() - 1);
                
                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            return historicalData.reverse();
        }
        
        function estimateBlockNumber(date) {
            // Ethereum averages ~12 second blocks
            // Use a recent reference point for accuracy
            const referenceDate = new Date('2025-09-01T00:00:00Z');
            const referenceBlock = 23261760; // Known block at reference date
            
            const secondsDiff = (date - referenceDate) / 1000;
            const blocksDiff = Math.floor(secondsDiff / 12);
            
            return Math.max(1, referenceBlock + blocksDiff);
        }
        
        async function fetchPoolDataAtBlock(poolAddress, blockNumber) {
            const url = `${V2_API}?chainId=1&blockNumber=${blockNumber}`;
            
            logToTerminal(`Fetching pool at block ${blockNumber}...`, 'comment');
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`API responded with ${response.status}`);
                }
                
                const pools = await response.json();
                
                // Find our pool in the response
                for (const pool of pools) {
                    if (pool.pool.toLowerCase() === poolAddress.toLowerCase()) {
                        return pool;
                    }
                }
                
                throw new Error('Pool not found in response');
            } catch (error) {
                logToTerminal(`Failed to fetch block ${blockNumber}: ${error.message}`, 'error');
                throw error;
            }
        }
        
        async function fetchSwapVolumes(poolAddress, startDate, endDate, decimals0, decimals1, token0, token1, feeRate = 0.00005) {
            // Use proxy if available (when served over HTTP), direct otherwise
            const GRAPHQL_URL = window.location.protocol === 'file:' 
                ? 'https://index-dev.euler.finance/graphql'
                : '/graphql-proxy';
            const volumes = {};
            
            logToTerminal('Fetching swap events from GraphQL...', 'info');
            logToTerminal(`Date range: ${startDate.toISOString().split('T')[0]} to ${endDate.toISOString().split('T')[0]}`, 'comment');
            
            // First fetch historical prices for the period
            const days = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
            const historicalPrices0 = await fetchHistoricalPrices(token0, days);
            const historicalPrices1 = await fetchHistoricalPrices(token1, days);
            
            // Query for swap events
            const query = `
                query GetSwaps($pool: String!, $startTime: BigInt!, $endTime: BigInt!) {
                    eulerSwapSwaps(
                        where: {
                            chainId: 1,
                            pool: $pool,
                            timestamp_gte: $startTime,
                            timestamp_lte: $endTime
                        },
                        orderBy: "timestamp",
                        orderDirection: "asc",
                        limit: 1000
                    ) {
                        items {
                            timestamp
                            amount0In
                            amount1In
                            amount0Out
                            amount1Out
                        }
                    }
                }
            `;
            
            try {
                const response = await fetch(GRAPHQL_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        query,
                        variables: {
                            pool: poolAddress.toLowerCase(),
                            startTime: Math.floor(startDate.getTime() / 1000).toString(),
                            endTime: Math.floor(endDate.getTime() / 1000).toString()
                        }
                    })
                });
                
                if (!response || !response.ok) {
                    throw new Error(`GraphQL request failed: ${response?.status || 'Network error'}`);
                }
                
                const data = await response.json();
                
                // Check for GraphQL errors
                if (data.errors) {
                    logToTerminal(`GraphQL errors: ${JSON.stringify(data.errors)}`, 'error');
                }
                
                const swaps = data.data?.eulerSwapSwaps?.items || [];
                
                logToTerminal(`Found ${swaps.length} swaps`, swaps.length > 0 ? 'success' : 'warning');
                
                // Debug: log the pool address being queried
                if (swaps.length === 0) {
                    const startTime = Math.floor(startDate.getTime() / 1000);
                    const endTime = Math.floor(endDate.getTime() / 1000);
                    logToTerminal(`Queried pool: ${poolAddress.toLowerCase()}`, 'comment');
                    logToTerminal(`Time range: ${startTime} to ${endTime} (${new Date(startTime * 1000).toISOString()} to ${new Date(endTime * 1000).toISOString()})`, 'comment');
                }
                
                // Group swaps by day and calculate volumes
                for (const swap of swaps) {
                    const swapDate = new Date(parseInt(swap.timestamp) * 1000);
                    const dateStr = swapDate.toISOString().split('T')[0];
                    
                    if (!volumes[dateStr]) {
                        volumes[dateStr] = { volume: 0, swaps: 0, fees: 0 };
                    }
                    
                    // Calculate volume (use the larger of in or out for each token)
                    const amount0In = parseFloat(swap.amount0In || 0) / Math.pow(10, decimals0);
                    const amount0Out = parseFloat(swap.amount0Out || 0) / Math.pow(10, decimals0);
                    const amount1In = parseFloat(swap.amount1In || 0) / Math.pow(10, decimals1);
                    const amount1Out = parseFloat(swap.amount1Out || 0) / Math.pow(10, decimals1);
                    
                    // Get historical prices for this date
                    const price0 = historicalPrices0[dateStr] || 1;
                    const price1 = historicalPrices1[dateStr] || 1;
                    
                    // Calculate USD volume using historical prices
                    const volume0USD = Math.max(amount0In, amount0Out) * price0;
                    const volume1USD = Math.max(amount1In, amount1Out) * price1;
                    
                    // Use average of both token volumes for accuracy
                    const swapVolume = (volume0USD + volume1USD) / 2;
                    
                    volumes[dateStr].volume += swapVolume;
                    volumes[dateStr].swaps += 1;
                    volumes[dateStr].fees += swapVolume * feeRate;
                }
                
            } catch (error) {
                console.error('Failed to fetch swap volumes:', error);
                logToTerminal(`GraphQL unavailable - Volume/swap data will be omitted`, 'warning');
                logToTerminal(`This is a known limitation of the Euler GraphQL endpoint`, 'info');
                
                // Return empty volumes - NAV will still work
                const currentDate = new Date(endDate);
                while (currentDate >= startDate) {
                    const dateStr = currentDate.toISOString().split('T')[0];
                    volumes[dateStr] = { volume: 0, swaps: 0, fees: 0 };
                    currentDate.setDate(currentDate.getDate() - 1);
                }
            }
            
            return volumes;
        }
        
        async function fetchHistoricalPrices(tokenAddress, days) {
            const prices = {};
            
            // Common stablecoins that are always ~$1
            const stablecoins = [
                '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC
                '0xdac17f958d2ee523a2206206994597c13d831ec7', // USDT
                '0x6b175474e89094c44da98b954eedeac495271d0f', // DAI
                '0x4fabb145d64652a948d72533023f6e7a623c7c53', // BUSD
                '0x8e870d67f660d95d5be530380d0ec0bd388289e1', // USDP
                '0x056fd409e1d7a124bd7017459dfea2f387b6d5cd', // GUSD
                '0x0000000000085d4780b73119b644ae5ecd22b376', // TUSD
                '0x4691937a7508860f876c9c0a2a617e7d9e945d4b', // USDe (Ethena)
                '0x8292bb45bf1ee4d140127049757c2e0ff06317ed', // RLUSD
            ];
            
            const tokenLower = tokenAddress.toLowerCase();
            
            // Check if it's a stablecoin
            if (stablecoins.includes(tokenLower) || tokenLower.includes('usd')) {
                // For stablecoins, return $1 for all dates
                const currentDate = new Date();
                for (let i = 0; i < days; i++) {
                    const date = new Date(currentDate);
                    date.setDate(date.getDate() - i);
                    const dateStr = date.toISOString().split('T')[0];
                    prices[dateStr] = 1;
                }
                logToTerminal(`Using $1 price for stablecoin ${tokenAddress.substring(0, 10)}...`, 'comment');
                return prices;
            }
            
            // For non-stablecoins, fetch from CoinGecko
            try {
                logToTerminal(`Fetching ${days} days of price history for ${tokenAddress.substring(0, 10)}...`, 'info');
                
                // CoinGecko API endpoint for historical data
                const url = `https://api.coingecko.com/api/v3/coins/ethereum/contract/${tokenAddress}/market_chart?vs_currency=usd&days=${days}`;
                
                logToTerminal(`API Call to CoinGecko`, 'url');
                logToTerminal(`  URL: ${url}`, 'comment');
                
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Process the price data
                    if (data.prices) {
                        for (const [timestamp, price] of data.prices) {
                            const date = new Date(timestamp);
                            const dateStr = date.toISOString().split('T')[0];
                            prices[dateStr] = price;
                        }
                        logToTerminal(`  Fetched ${Object.keys(prices).length} days of price data`, 'success');
                    }
                } else if (response.status === 404) {
                    // Token not found on CoinGecko, try GraphQL oracle prices
                    logToTerminal(`  Token not on CoinGecko, fetching oracle prices...`, 'comment');
                    
                    const oraclePrices = await fetchOraclePrices(tokenAddress, days);
                    Object.assign(prices, oraclePrices);
                } else {
                    logToTerminal(`  CoinGecko API error: ${response.status}`, 'error');
                }
                
            } catch (error) {
                console.error('Failed to fetch historical prices:', error);
                logToTerminal(`Failed to fetch prices: ${error.message}`, 'error');
                
                // Fallback to current price for all days
                const currentPrice = await getCurrentPrice(tokenAddress);
                const currentDate = new Date();
                for (let i = 0; i < days; i++) {
                    const date = new Date(currentDate);
                    date.setDate(date.getDate() - i);
                    const dateStr = date.toISOString().split('T')[0];
                    prices[dateStr] = currentPrice;
                }
            }
            
            // Add small delay to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 500));
            
            return prices;
        }
        
        async function fetchOraclePrices(tokenAddress, days) {
            const GRAPHQL_URL = window.location.protocol === 'file:' 
                ? 'https://index-dev.euler.finance/graphql'
                : '/graphql-proxy';
            const prices = {};
            
            try {
                // Get oracle prices for each day
                const currentDate = new Date();
                
                for (let i = 0; i < days; i++) {
                    const date = new Date(currentDate);
                    date.setDate(date.getDate() - i);
                    const dateStr = date.toISOString().split('T')[0];
                    
                    // Estimate block for this date
                    const blockNumber = estimateBlockNumber(date);
                    
                    const query = `
                        query GetPrice($chainId: Int!, $asset: String!, $blockTag: BigInt) {
                            price(chainId: $chainId, asset: $asset, blockTag: $blockTag) {
                                price
                            }
                        }
                    `;
                    
                    let response;
                    try {
                        response = await fetch(GRAPHQL_URL, {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'Accept': 'application/json'
                            },
                            body: JSON.stringify({
                                query,
                                variables: {
                                    chainId: 1,
                                    asset: tokenAddress.toLowerCase(),
                                    blockTag: blockNumber.toString()
                                }
                            })
                        });
                    } catch (error) {
                        // Try CORS proxy if direct fails
                        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(GRAPHQL_URL)}`;
                        response = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'Accept': 'application/json'
                            },
                            body: JSON.stringify({
                                query,
                                variables: {
                                    chainId: 1,
                                    asset: tokenAddress.toLowerCase(),
                                    blockTag: blockNumber.toString()
                                }
                            })
                        });
                    }
                    
                    const data = await response.json();
                    if (data.data?.price?.price) {
                        // Oracle price is in 8 decimals
                        prices[dateStr] = parseFloat(data.data.price.price) / 1e8;
                    } else {
                        // Default to $1 if no price available
                        prices[dateStr] = 1;
                    }
                }
                
                logToTerminal(`  Fetched ${Object.keys(prices).length} days of oracle prices`, 'success');
                
            } catch (error) {
                console.error('Failed to fetch oracle prices:', error);
                logToTerminal(`Failed to fetch oracle prices: ${error.message}`, 'error');
            }
            
            return prices;
        }
        
        async function getCurrentPrice(tokenAddress) {
            // Try to get current price from GraphQL
            const GRAPHQL_URL = window.location.protocol === 'file:' 
                ? 'https://index-dev.euler.finance/graphql'
                : '/graphql-proxy';
            
            try {
                const query = `
                    query GetPrice($chainId: Int!, $asset: String!) {
                        price(chainId: $chainId, asset: $asset) {
                            price
                        }
                    }
                `;
                
                let response;
                try {
                    response = await fetch(GRAPHQL_URL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify({
                            query,
                            variables: {
                                chainId: 1,
                                asset: tokenAddress.toLowerCase()
                            }
                        })
                    });
                } catch (error) {
                    // Try CORS proxy if direct fails
                    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(GRAPHQL_URL)}`;
                    response = await fetch(proxyUrl, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify({
                            query,
                            variables: {
                                chainId: 1,
                                asset: tokenAddress.toLowerCase()
                            }
                        })
                    });
                }
                
                const data = await response.json();
                if (data.data?.price?.price) {
                    return parseFloat(data.data.price.price) / 1e8;
                }
            } catch (error) {
                console.error('Failed to get current price:', error);
            }
            
            // Default to $1
            return 1;
        }

        async function getTokenSymbol(address) {
            // Common tokens cache
            const symbols = {
                '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 'USDC',
                '0xdac17f958d2ee523a2206206994597c13d831ec7': 'USDT',
                '0xc02aaa39bb223dc46d80f1ecd791860909c726e2': 'WETH',
                '0x83f20f44975d03b1b09e64809b757c47f942beea': 'sDAI',
                '0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0': 'wstETH',
            };
            
            const cached = symbols[address.toLowerCase()];
            if (cached) return cached;
            
            // Try to fetch symbol from chain
            try {
                // ERC20 symbol() function selector
                const symbolSelector = '0x95d89b41';
                
                const payload = {
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'eth_call',
                    params: [{
                        to: address,
                        data: symbolSelector
                    }, 'latest']
                };
                
                logToTerminal(`RPC Call to ${RPC_URL}`, 'url');
                logToTerminal(`Method: eth_call(symbol) to ${address}`, 'comment');
                
                const response = await fetch(RPC_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                logToTerminal(`RPC Response: ${result.result || 'null'}`, 'json');
                
                if (result.result && result.result !== '0x') {
                    // Decode the symbol from hex
                    // The result is ABI encoded: offset (32 bytes) + length (32 bytes) + data
                    const hex = result.result.slice(2); // Remove 0x
                    
                    // Skip first 64 chars (32 bytes offset)
                    // Next 64 chars (32 bytes) is the string length
                    const lengthHex = hex.slice(64, 128);
                    const length = parseInt(lengthHex, 16);
                    
                    if (length > 0 && length < 32) {
                        // Get the actual string bytes
                        const stringHex = hex.slice(128, 128 + length * 2);
                        
                        // Convert hex to string
                        let symbol = '';
                        for (let i = 0; i < stringHex.length; i += 2) {
                            const charCode = parseInt(stringHex.substr(i, 2), 16);
                            if (charCode > 0) {
                                symbol += String.fromCharCode(charCode);
                            }
                        }
                        
                        // Clean up any non-printable characters
                        symbol = symbol.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
                        
                        if (symbol.length > 0) {
                            console.log(`Fetched symbol for ${address}: ${symbol}`);
                            return symbol;
                        }
                    }
                }
            } catch (error) {
                console.error('Error fetching token symbol:', error);
            }
            
            // Fallback to shortened address
            return address.slice(0, 6).toUpperCase();
        }
        
        async function getTokenDecimals(address) {
            // Check known decimals first
            const decimals = KNOWN_DECIMALS[address.toLowerCase()];
            if (decimals !== undefined) return decimals;
            
            try {
                // ERC20 decimals() function selector
                const decimalsSelector = '0x313ce567';
                
                const payload = {
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'eth_call',
                    params: [{
                        to: address,
                        data: decimalsSelector
                    }, 'latest']
                };
                
                logToTerminal(`RPC Call to ${RPC_URL}`, 'url');
                logToTerminal(`Method: eth_call(decimals) to ${address}`, 'comment');
                
                const response = await fetch(RPC_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                logToTerminal(`RPC Response: ${result.result || 'null'} (${parseInt(result.result, 16)} decimals)`, 'json');
                
                if (result.result && result.result !== '0x') {
                    const decimals = parseInt(result.result, 16);
                    if (decimals >= 0 && decimals <= 77) {
                        console.log(`Fetched decimals for ${address}: ${decimals}`);
                        return decimals;
                    }
                }
            } catch (error) {
                console.error('Error fetching token decimals:', error);
            }
            
            return 18; // Default to 18 decimals
        }

        function displayResults(data) {
            document.getElementById('results').style.display = 'block';
            
            const { pool, historical } = data;
            const latestNav = historical[historical.length - 1];
            const previousNav = historical[historical.length - 2] || latestNav;
            
            // Update pool info
            document.getElementById('tokenPair').textContent = `${latestNav.token0Symbol}/${latestNav.token1Symbol}`;
            document.getElementById('poolAddr').textContent = pool.pool || pool.address;
            document.getElementById('feeBadge').textContent = `${((pool.fee || 0) / 1e18 * 10000).toFixed(2)} bps`;
            
            // Update metrics
            document.getElementById('currentNav').textContent = `$${formatNumber(latestNav.nav)}`;
            
            const change = latestNav.nav - previousNav.nav;
            const changePercent = (change / previousNav.nav * 100).toFixed(2);
            const changeElement = document.getElementById('navChange');
            changeElement.textContent = `${change >= 0 ? '+' : ''}${changePercent}%`;
            changeElement.className = `metric-value ${change >= 0 ? 'green' : 'red'}`;
            
            const totalFees = historical.reduce((sum, d) => sum + d.fees, 0);
            document.getElementById('totalFees').textContent = `$${formatNumber(totalFees)}`;
            
            // Calculate Total NAV APR (first to last)
            if (historical.length > 1) {
                const firstNav = historical[0].nav;
                const lastNav = historical[historical.length - 1].nav;
                const days = historical.length;
                
                if (firstNav > 0) {
                    // Calculate annualized return: ((final/initial)^(365/days) - 1) * 100
                    const navApr = (Math.pow(lastNav / firstNav, 365 / days) - 1) * 100;
                    document.getElementById('navApr').textContent = `${navApr.toFixed(2)}%`;
                } else {
                    document.getElementById('navApr').textContent = 'N/A';
                }
            } else {
                document.getElementById('navApr').textContent = 'N/A';
            }
            
            const avgNav = historical.reduce((sum, d) => sum + d.nav, 0) / historical.length;
            const feeApr = (totalFees / avgNav) * (365 / historical.length) * 100;
            document.getElementById('feeApr').textContent = `${feeApr.toFixed(2)}%`;
            
            const totalVolume = historical.reduce((sum, d) => sum + d.volume, 0);
            document.getElementById('totalVolume').textContent = `$${formatNumber(totalVolume)}`;
            
            const totalSwaps = historical.reduce((sum, d) => sum + d.swaps, 0);
            document.getElementById('totalSwaps').textContent = totalSwaps.toLocaleString();
            
            // Calculate additional statistics
            const avgDailyVolume = totalVolume / historical.length;
            document.getElementById('avgDailyVolume').textContent = `$${formatNumber(avgDailyVolume)}`;
            
            const navValues = historical.map(d => d.nav);
            const maxNav = Math.max(...navValues);
            const minNav = Math.min(...navValues);
            document.getElementById('maxNav').textContent = `$${formatNumber(maxNav)}`;
            document.getElementById('minNav').textContent = `$${formatNumber(minNav)}`;
            
            // Calculate NAV volatility (standard deviation of daily returns)
            const dailyReturns = [];
            for (let i = 1; i < historical.length; i++) {
                if (historical[i-1].nav > 0) {
                    const dailyReturn = (historical[i].nav - historical[i-1].nav) / historical[i-1].nav;
                    dailyReturns.push(dailyReturn);
                }
            }
            
            if (dailyReturns.length > 0) {
                const avgReturn = dailyReturns.reduce((a, b) => a + b, 0) / dailyReturns.length;
                const variance = dailyReturns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / dailyReturns.length;
                const volatility = Math.sqrt(variance) * Math.sqrt(365) * 100; // Annualized
                document.getElementById('navVolatility').textContent = `${volatility.toFixed(2)}%`;
                
                // Sharpe Ratio (simplified - assuming 0% risk-free rate)
                const annualizedReturn = avgReturn * 365;
                const sharpe = annualizedReturn / (Math.sqrt(variance) * Math.sqrt(365));
                document.getElementById('sharpeRatio').textContent = sharpe.toFixed(2);
                
                // Best and worst day
                const maxReturn = Math.max(...dailyReturns) * 100;
                const minReturn = Math.min(...dailyReturns) * 100;
                document.getElementById('bestDay').textContent = `+${maxReturn.toFixed(2)}%`;
                document.getElementById('worstDay').textContent = `${minReturn.toFixed(2)}%`;
                
                // Win rate (percentage of positive days)
                const winDays = dailyReturns.filter(r => r > 0).length;
                const winRate = (winDays / dailyReturns.length) * 100;
                document.getElementById('winRate').textContent = `${winRate.toFixed(1)}%`;
            } else {
                document.getElementById('navVolatility').textContent = 'N/A';
                document.getElementById('sharpeRatio').textContent = 'N/A';
                document.getElementById('bestDay').textContent = 'N/A';
                document.getElementById('worstDay').textContent = 'N/A';
                document.getElementById('winRate').textContent = 'N/A';
            }
            
            // Update chart
            updateChart(historical);
            
            // Update table
            updateTable(historical);
        }

        function updateChart(data) {
            const ctx = document.getElementById('navChart').getContext('2d');
            
            if (navChart) {
                navChart.destroy();
            }
            
            navChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => d.date),
                    datasets: [{
                        label: 'NAV (USD)',
                        data: data.map(d => d.nav),
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => `NAV: $${formatNumber(context.parsed.y)}`
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: (value) => `$${formatNumber(value)}`
                            }
                        }
                    }
                }
            });
        }

        function updateTable(data) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            data.forEach((day, index) => {
                const row = tbody.insertRow();
                
                // Add error styling if data fetch failed
                if (day.error) {
                    row.style.opacity = '0.6';
                }
                
                row.insertCell(0).textContent = day.date;
                row.insertCell(1).textContent = `$${formatNumber(day.nav)}`;
                
                const changeCell = row.insertCell(2);
                if (day.navChangePercent !== 0 || index > 0) {
                    const change = day.navChangePercent || 0;
                    changeCell.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                    changeCell.style.color = change >= 0 ? '#10b981' : '#ef4444';
                } else {
                    changeCell.textContent = '-';
                }
                
                row.insertCell(3).textContent = `$${formatNumber(day.volume)}`;
                row.insertCell(4).textContent = `$${formatNumber(day.fees)}`;
                row.insertCell(5).textContent = day.swaps || 0;
            });
        }

        let returnsChart = null;
        let volumeChart = null;
        let drawdownChart = null;
        
        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.getElementById(`${tab}-tab`).classList.add('active');
            
            // Initialize charts as needed
            if (currentData) {
                const historical = currentData.historical;
                
                if (tab === 'composition' && !compositionChart) {
                    const ctx = document.getElementById('compositionChart').getContext('2d');
                    compositionChart = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: [historical[0].token0Symbol, historical[0].token1Symbol],
                            datasets: [{
                                data: [50, 50], // Simplified - would need actual reserve data
                                backgroundColor: ['#667eea', '#764ba2']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false
                        }
                    });
                }
                
                // Daily Returns Chart
                if (tab === 'returns') {
                    const ctx = document.getElementById('returnsChart').getContext('2d');
                    
                    if (returnsChart) {
                        returnsChart.destroy();
                    }
                    
                    const dailyReturns = [];
                    const labels = [];
                    
                    for (let i = 1; i < historical.length; i++) {
                        if (historical[i-1].nav > 0) {
                            const dailyReturn = ((historical[i].nav - historical[i-1].nav) / historical[i-1].nav) * 100;
                            dailyReturns.push(dailyReturn);
                            labels.push(historical[i].date);
                        }
                    }
                    
                    returnsChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Daily Return (%)',
                                data: dailyReturns,
                                backgroundColor: dailyReturns.map(r => r >= 0 ? 'rgba(16, 185, 129, 0.6)' : 'rgba(239, 68, 68, 0.6)'),
                                borderColor: dailyReturns.map(r => r >= 0 ? '#10b981' : '#ef4444'),
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: (context) => `Return: ${context.parsed.y.toFixed(3)}%`
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        callback: (value) => `${value}%`
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Volume & Fees Chart
                if (tab === 'volume') {
                    const ctx = document.getElementById('volumeChart').getContext('2d');
                    
                    if (volumeChart) {
                        volumeChart.destroy();
                    }
                    
                    volumeChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: historical.map(d => d.date),
                            datasets: [{
                                label: 'Volume',
                                data: historical.map(d => d.volume),
                                backgroundColor: 'rgba(102, 126, 234, 0.5)',
                                borderColor: '#667eea',
                                borderWidth: 1,
                                yAxisID: 'y',
                                order: 2
                            }, {
                                label: 'Fees',
                                data: historical.map(d => d.fees),
                                type: 'line',
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                borderWidth: 2,
                                yAxisID: 'y1',
                                order: 1,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false,
                            },
                            plugins: {
                                legend: { display: true },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            let label = context.dataset.label || '';
                                            if (label) {
                                                label += ': $';
                                            }
                                            if (context.parsed.y !== null) {
                                                label += formatNumber(context.parsed.y);
                                            }
                                            return label;
                                        }
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    type: 'linear',
                                    display: true,
                                    position: 'left',
                                    ticks: {
                                        callback: (value) => `$${formatNumber(value)}`
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    grid: {
                                        drawOnChartArea: false,
                                    },
                                    ticks: {
                                        callback: (value) => `$${formatNumber(value)}`
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Drawdown Chart
                if (tab === 'drawdown') {
                    const ctx = document.getElementById('drawdownChart').getContext('2d');
                    
                    if (drawdownChart) {
                        drawdownChart.destroy();
                    }
                    
                    // Calculate drawdown from peak
                    const drawdowns = [];
                    let peak = historical[0].nav;
                    
                    for (let i = 0; i < historical.length; i++) {
                        if (historical[i].nav > peak) {
                            peak = historical[i].nav;
                        }
                        const drawdown = ((historical[i].nav - peak) / peak) * 100;
                        drawdowns.push(drawdown);
                    }
                    
                    drawdownChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: historical.map(d => d.date),
                            datasets: [{
                                label: 'Drawdown (%)',
                                data: drawdowns,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: (context) => `Drawdown: ${context.parsed.y.toFixed(2)}%`
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    max: 0,
                                    ticks: {
                                        callback: (value) => `${value}%`
                                    }
                                }
                            }
                        }
                    });
                }
            }
        }

        function exportToCSV() {
            if (!currentData) return;
            
            const csv = [
                ['Date', 'NAV (USD)', 'Volume', 'Fees', 'Swaps'],
                ...currentData.historical.map(d => [
                    d.date,
                    d.nav,
                    d.volume,
                    d.fees,
                    d.swaps
                ])
            ].map(row => row.join(',')).join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `eulerswap-nav-${currentData.pool.pool || 'export'}.csv`;
            a.click();
        }

        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(2) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(2) + 'K';
            }
            return num.toFixed(2);
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.querySelector('button').disabled = show;
        }

        function updateStatus(message) {
            document.getElementById('loadingStatus').textContent = message;
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        // Allow Enter key to submit
        document.getElementById('poolAddress').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') fetchPoolData();
        });
    </script>
</body>
</html>